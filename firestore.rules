rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isSignedIn() {
      return request.auth != null;
    }

    function isAdmin() {
      // Add your admin UIDs here
      return isSignedIn() && (request.auth.uid in ["S3YNVH6Tn8RCauiQrj2oy6e37FI3","QURZGWBt6sTa0Zv8dn0qj4tldh12","X6QLjRFs5vf38H7hoG7zcmiDZhy2"]);
    }

    // Helper function to check for a two-way block.
    function isBlocked(userId1, userId2) {
      return exists(/databases/$(database)/documents/blocks/$(userId1 + '_' + userId2)) ||
             exists(/databases/$(database)/documents/blocks/$(userId2 + '_' + userId1));
    }

    // --- Collections ---

    // users: Public read, only owner can write.
    match /users/{userId} {
      allow read: if true;
      allow create, update, delete: if isSignedIn() && request.auth.uid == userId;

      // userAchievements: Public read, only backend can write.
      match /userAchievements/{achievementId} {
        allow read: if true;
        allow write: if false; // Prevent client-side awarding
      }
    }

    // achievements: Public read, only admin can write.
    match /achievements/{achievementId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // usernames: Public read for availability checks, owner can write.
    match /usernames/{uname} {
      allow read: if true;
      allow write: if isSignedIn() && request.resource.data.uid == request.auth.uid;
    }

    // outfits: Public read. Owner can create/delete.
    // Update is allowed by owner, or by any user if ONLY counters are changing.
    match /outfits/{outfitId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && request.auth.uid == resource.data.userId;
      allow update: if isSignedIn() && request.auth.uid == resource.data.userId;
    }

    // comments: Public read. Owner can create.
    // Delete is allowed by comment author, post owner, or admin.
    match /comments/{commentId} {
      allow read: if true;

      allow create: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.outfitId is string
        && request.resource.data.text is string && request.resource.data.text.size() > 0
        && (!('parentId' in request.resource.data) || request.resource.data.parentId is string || request.resource.data.parentId == null)
        && !isBlocked(request.auth.uid, request.resource.data.postOwnerId);

      allow update: if isSignedIn() && request.auth.uid == resource.data.userId;
      allow delete: if isSignedIn() && (
        request.auth.uid == resource.data.userId ||
        isAdmin() ||
        get(/databases/$(database)/documents/outfits/$(resource.data.outfitId)).data.userId == request.auth.uid
      );
    }

    // likes: Signed-in users can read. Owner can create/delete their own like.
    match /likes/{likeId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn()
        && request.auth.uid == request.resource.data.userId
        && likeId == request.resource.data.outfitId + '_' + request.auth.uid
        && !isBlocked(request.auth.uid, get(/databases/$(database)/documents/outfits/$(request.resource.data.outfitId)).data.userId);
      allow delete: if isSignedIn() && request.auth.uid == resource.data.userId;
      allow update: if false;
    }

    // saves: Signed-in users can read. Owner can create/delete their own save.
    match /saves/{saveId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn()
        && request.auth.uid == request.resource.data.userId
        && saveId == request.resource.data.outfitId + '_' + request.auth.uid;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow update: if false;
    }

    // follows: Signed-in users can read. Owner can create/delete their own follow relationship.
    match /follows/{followId} {
      function parts() { return followId.split('_'); }
      function followerId() { return parts().size() == 2 ? parts()[0] : ''; }
      function followingId() { return parts().size() == 2 ? parts()[1] : ''; }

      allow read: if isSignedIn();
      allow create: if isSignedIn()
        && request.auth.uid == followerId()
        && followerId() != followingId()
        && request.resource.data.followerId == followerId()
        && request.resource.data.followingId == followingId();
      allow delete: if isSignedIn() && (request.auth.uid == followerId() || request.auth.uid == followingId());
      allow update: if false;
    }

    // blocks: A user can create/delete their own block records.
    match /blocks/{blockId} {
      function blockerId() { return blockId.split('_')[0]; }
      function blockedId() { return blockId.split('_')[1]; }

      allow read: if isSignedIn() && (request.auth.uid == blockerId() || request.auth.uid == blockedId());
      allow create: if isSignedIn()
        && request.auth.uid == blockerId()
        && request.resource.data.blockerId == blockerId()
        && request.resource.data.blockedId == blockedId();
      allow delete: if isSignedIn() && request.auth.uid == blockerId();
      allow update: if false;
    }

    // notifications: Read-only for the recipient. Created by Cloud Functions.
    match /notifications/{notificationId} {
      // A user can read (get or list) notifications if they are the recipient.
      allow read: if isSignedIn() && request.auth.uid == resource.data.recipientId;
      // Allow the recipient to update the 'read' status.
      allow update: if isSignedIn() && request.auth.uid == resource.data.recipientId && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
      allow create: if false; // Only backend can create notifications
      allow delete: if false; // Disallow client-side deletion
    }

    // contests: Public read, only admin can write.
    match /contests/{contestId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }

    // entries: Public read. Owner can create. Stats can be updated.
    match /entries/{entryId} {
      allow read: if true;
      allow create: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.contestId is string
        && request.resource.data.imageUrl is string;

      function onlyStatsChanged() {
        return request.resource.data.diff(resource.data).changedKeys().hasOnly(
          ['averageRating','ratingsCount','aiFlagsCount']
        );
      }

      allow update: if isSignedIn() && (
        onlyStatsChanged() ||
        (request.auth.uid == resource.data.userId && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['caption', 'tags', 'status'])) ||
        isAdmin()
      );
      allow delete: if isAdmin();
    }

    // problemReports: Users can create, admins can read/update.
    match /problemReports/{reportId} {
      allow create: if isSignedIn() && request.resource.data.reporterId == request.auth.uid;
      allow read, update, delete: if isAdmin();
    }

    // verificationApplications: Users can create for themselves. Admins can manage.
    match /verificationApplications/{applicationId} {
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow read, update, delete: if isAdmin();
    }

    // ratings: Public read. Owner can create/update their own rating.
    match /ratings/{ratingId} {
      allow read: if true;
      allow create, update: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && (request.resource.data.entryId is string || request.resource.data.outfitId is string)
        && (ratingId == (request.resource.data.entryId + "_" + request.resource.data.userId) || ratingId == (request.resource.data.outfitId + "_" + request.resource.data.userId))
        && request.resource.data.rating is number
        && request.resource.data.rating >= 0 && request.resource.data.rating <= 10
        && request.resource.data.aiFlag is bool;
      allow delete: if isAdmin();
    }

    // shares: A user can read shares sent to them. They can create shares.
    // They can update their own received shares (to add a reaction).
    match /shares/{shareId} {
      allow read, list: if isSignedIn() && (request.auth.uid == resource.data.recipientId || request.auth.uid == resource.data.senderId);
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.senderId;
      // Allow sender/recipient to update specific fields.
      allow update: if isSignedIn() && (
        (request.auth.uid == resource.data.recipientId && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reaction', 'read', 'deletedByRecipient'])) ||
        (request.auth.uid == resource.data.senderId && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['deletedBySender']))
      );
      // Users can delete shares if they are the sender or recipient (for "Delete for Everyone").
      allow delete: if isSignedIn() && (request.auth.uid == resource.data.recipientId || request.auth.uid == resource.data.senderId);
    }

    match /problemReports/{reportId} {
  allow create: if isSignedIn() && request.resource.data.reporterId == request.auth.uid;
  allow read, update, delete: if isAdmin(); // This line already permits the update.
   }
  }
}